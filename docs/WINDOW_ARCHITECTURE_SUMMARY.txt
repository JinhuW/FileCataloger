=============================================================================
          FILECATALOGER WINDOW MANAGEMENT ARCHITECTURE SUMMARY
=============================================================================

QUESTION: How are shelf windows created and managed?
ANSWER: Through a sophisticated two-layer architecture combining Electron 
        BrowserWindows with React UI.

=============================================================================
                            THE COMPLETE FLOW
=============================================================================

USER ACTION: Shakes mouse while dragging files
    |
    v
MOUSE TRACKING: Native CGEventTap detects motion (60fps)
    |
    v
SHAKE DETECTION: 6+ direction changes in 500ms detected
    |
    v
STATE MACHINE: Transitions to SHAKE_DETECTED state
    |
    v
SHELF CREATION REQUEST: Sent to ShelfLifecycleManager
    |
    v
DUPLICATE CHECK: Uses Mutex to prevent race conditions
    |
    v
WINDOW ACQUISITION: Gets window from AdvancedWindowPool
    |
    v
WINDOW CONFIGURATION:
    - Set size (900x600 for rename, 400x600 for display)
    - Set position (at mouse cursor)
    - Set transparency (frame: false, transparent: true)
    - Set behavior (alwaysOnTop: true, skipTaskbar: true)
    |
    v
CONTENT LOADING: Load shelf.html into BrowserWindow
    |
    v
REACT BOOTSTRAP: shelf.tsx mounts ShelfPage component
    |
    v
STATE SYNCHRONIZATION: 
    - IPC sends shelf config to renderer
    - Zustand store updates with shelf data
    - React renders FileRenameShelf component
    |
    v
WINDOW DISPLAY: window.show() makes it visible
    |
    v
USER INTERACTION: Drag files onto shelf, rename them

=============================================================================
                           WHY "INVISIBLE"?
=============================================================================

ELECTRON WINDOW SETTINGS:
    frame: false                  → No title bar, no decorations
    transparent: true            → Transparent background
    hasShadow: false             → No native shadow
    skipTaskbar: true            → Not in taskbar
    closable: false              → No close button

HTML SETTINGS (shelf.html):
    body { background: transparent }
    #root { width: 100vw; height: 100vh }

RESULT:
    The Electron window itself is invisible - just a transparent container.
    Only the React-rendered content is visible (Tailwind CSS styled).
    The visual effect is a floating, frameless UI.

=============================================================================
                           TWO-LAYER ARCHITECTURE
=============================================================================

LAYER 1: ELECTRON WINDOW (Main Process)
    Purpose: OS-level window container
    Features:
        - Can be positioned, moved, resized
        - Receives/sends events (mouse, keyboard, etc.)
        - Manages window lifecycle
        - Communicates via IPC
    Location: BrowserWindow instances in AdvancedWindowPool

LAYER 2: REACT UI (Renderer Process)
    Purpose: Visual content and interaction
    Features:
        - React components rendering UI
        - Zustand store for state management
        - Tailwind CSS for styling
        - IPC communication with main process
    Location: shelf.tsx → ShelfPage → FileRenameShelf

SYNERGY:
    Electron handles low-level window management
    React handles high-level UI and interaction
    IPC bridges the gap between them

=============================================================================
                         WINDOW POOLING STRATEGY
=============================================================================

WHY POOL WINDOWS?
    - Cold start (new window): 500ms to create
    - Pooled reuse: 50ms to retrieve
    - Improvement: 90% faster

POOL ARCHITECTURE:
    Warm Pool:
        - Max 2 pre-initialized windows
        - Ready for immediate use
        - HTML already loaded
    
    Cold Pool:
        - Max 3 basic windows
        - Need initialization
        - Cached for quick warmup
    
    In-Use Map:
        - Track currently active windows
        - Monitor window lifecycle
        - Clean up on destruction
    
    Total Limit: 5 windows maximum

FLOW:
    1. getWindow() requested
    2. Check warm pool (fast, 50ms)
    3. If empty, check cold pool (medium, 100ms)
    4. If empty, create new (slow, 500ms)
    5. Warm up if cold
    6. Return to caller
    
    When done:
    1. releaseWindow() called
    2. Clean window state
    3. Return to appropriate pool
    4. Reuse next time

=============================================================================
                        STATE MANAGEMENT FLOW
=============================================================================

MAIN PROCESS: ShelfManager maintains shelf registry
    shelfConfigs: Map<shelfId, ShelfConfig>
    shelves: Map<shelfId, BrowserWindow>
    activeShelves: Set<shelfId>

COMMUNICATION: IPC sends config to renderer
    window.webContents.send('shelf:config', config)

RENDERER: Zustand store manages UI state
    useShelfStore = Zustand store with Immer
    shelves: Map<shelfId, Shelf>
    
    Actions:
    - addShelf(config)
    - updateShelf(id, updates)
    - addItemToShelf(id, item)
    - removeItemFromShelf(id, itemId)
    - getShelf(id)

REACT: Components subscribe to store
    const shelf = useShelfStore(state => state.getShelf(shelfId))
    
    When shelf changes:
    - ShelfPage component re-renders
    - FileRenameShelf updates with new data
    - UI reflects current state

=============================================================================
                         KEY FILE LOCATIONS
=============================================================================

MAIN PROCESS (Window Management):
    src/main/modules/window/shelf_manager.ts (377 lines)
        - createShelf(): Main window creation method
        - configureShelfWindow(): Sets window properties
        - addItemToShelf(): Updates shelf contents
        - destroyShelf(): Cleanup and pooling
    
    src/main/modules/window/advanced_window_pool.ts (460 lines)
        - getWindow(): Retrieve from pool
        - releaseWindow(): Return to pool
        - createWindow(): Create new BrowserWindow
        - warmUpWindow(): Pre-load HTML content
        - cleanup(): Garbage collection

RENDERER PROCESS (UI):
    src/renderer/pages/shelf/shelf.html (31 lines)
        - Basic HTML with transparent body
        - Root div for React mounting
    
    src/renderer/pages/shelf/shelf.tsx (64 lines)
        - React bootstrap code
        - Error boundary wrapper
        - Component mounting
    
    src/renderer/pages/shelf/ShelfPage.tsx (150+ lines)
        - Main page component
        - IPC listener setup
        - Zustand store integration
        - Conditional rendering (rename vs display mode)

STATE MANAGEMENT:
    src/renderer/stores/shelfStore.ts
        - Zustand store definition
        - Map-based shelf storage
        - All shelf operations
    
    src/shared/types.ts
        - ShelfConfig interface
        - ShelfItem interface
        - Shared types between processes

CONFIGURATION:
    config/webpack/webpack.renderer.js
        - Entry points: shelf, preferences, demo
        - Output: dist/renderer/
        - HtmlWebpackPlugin for shelf.html

=============================================================================
                            COMMUNICATION PATTERN
=============================================================================

IPC MESSAGES (Main → Renderer):
    shelf:config
        Sent when: Shelf created or updated
        Payload: ShelfConfig object
        Handler: ShelfPage listens with useIPC() hook
    
    shelf:item-added
        Sent when: File dropped on shelf
        Payload: ShelfItem object
        Handler: Zustand store action triggered
    
    shelf:item-removed
        Sent when: Item deleted from shelf
        Payload: itemId string
        Handler: Zustand store removes item

PRELOAD SCRIPT BRIDGE:
    src/preload/index.ts
        - Validates all IPC channels
        - Provides window.electronAPI.*
        - Rate limiting on messages
        - Security validation

RENDERER → MAIN:
    window.electronAPI.shelf.filesDropped(shelfId, items)
    window.electronAPI.shelf.close(shelfId)
    window.electronAPI.app.getStatus()

=============================================================================
                         WINDOW LIFECYCLE EVENTS
=============================================================================

CREATION:
    ShelfManager.createShelf()
        ├─ Check for duplicates (Mutex)
        ├─ Generate unique shelf ID
        ├─ Acquire window from pool
        ├─ Configure window properties
        ├─ Load shelf.html content
        ├─ Send IPC config message
        ├─ Setup event handlers
        ├─ Show window
        └─ Return shelf ID

INTERACTION:
    User clicks, types, drags files
        → React handles events
        → Zustand store updates
        → Components re-render
        → IPC messages to main process

DESTRUCTION:
    ShelfManager.destroyShelf()
        ├─ Undock if needed
        ├─ Release window to pool
        │   ├─ Clean window state
        │   ├─ Hide window
        │   ├─ Reset position/size/opacity
        │   └─ Return to warm/cold pool
        ├─ Delete configurations
        ├─ Remove from tracking
        └─ Emit 'shelf-destroyed' event

=============================================================================
                        PERFORMANCE OPTIMIZATIONS
=============================================================================

WINDOW POOLING:
    Reuse windows instead of destroying them
    Warm pool keeps 2 ready, cold pool has 3 backups
    90% faster window acquisition

EVENT BATCHING:
    Mouse events capped at 60fps (16.67ms)
    Prevents event flooding
    Reduces CPU usage by 70%

VIRTUAL LISTS:
    Large file lists use virtualization
    Only renders visible items
    Smooth scrolling with thousands of files

SELECTIVE RE-RENDERS:
    Zustand selectors optimize subscriptions
    React.memo prevents unnecessary renders
    Components only update when their data changes

IPC RATE LIMITING:
    Throttles IPC messages
    Prevents main process flooding
    Default: 100 messages per second per window

=============================================================================
                          DEBUGGING CHECKLIST
=============================================================================

Window Not Appearing?
    [ ] Check window pool initialized
    [ ] Verify shake detection triggered
    [ ] Check shelf.html loaded successfully
    [ ] Verify React mounted without errors
    [ ] Check window.show() was called
    [ ] Verify window not hidden behind other windows
    [ ] Check transparency settings

IPC Communication Failing?
    [ ] Preload script loaded (check console)
    [ ] IPC channel in whitelist (preload)
    [ ] Message format matches interface
    [ ] Rate limiter not triggered
    [ ] Both processes running

High CPU/Memory Usage?
    [ ] Check window pool size
    [ ] Verify event listeners cleaned up
    [ ] Monitor React re-renders
    [ ] Check for timer leaks
    [ ] Verify native module not crashing

=============================================================================
                              KEY INSIGHTS
=============================================================================

1. TRANSPARENCY IS THE KEY
   The window itself is invisible. Only React components are visible.
   This creates a lightweight, custom-styled floating UI.

2. POOLING SAVES TIME
   Pre-creating and reusing windows cuts creation time 90%.
   Warm pool = instant, cold pool = quick, create = fallback.

3. TWO PROCESSES WORK TOGETHER
   Main process manages OS-level window lifecycle.
   Renderer process manages UI and interaction.
   IPC bridges them seamlessly.

4. MAP-BASED STATE FOR PERFORMANCE
   Zustand uses Map for O(1) shelf lookups.
   Immer enables immutable updates.
   Selectors prevent unnecessary re-renders.

5. IPC IS THE BOTTLENECK
   Rate limiting prevents message flooding.
   Validation ensures data integrity.
   Preload script provides security layer.

6. MODULARITY ENABLES SCALABILITY
   ShelfManager handles windows.
   ShelfLifecycleManager handles lifecycle.
   DragDropCoordinator handles input.
   Each module has single responsibility.

=============================================================================
                           QUICK START GUIDE
=============================================================================

To understand the flow:
    1. Start with ShelfManager.createShelf() in shelf_manager.ts
    2. Follow to AdvancedWindowPool.getWindow()
    3. See how BrowserWindow is created and configured
    4. Check loadShelfContent() to see HTML loading
    5. Look at shelf.tsx for React bootstrap
    6. Study ShelfPage component for state management
    7. Review Zustand store for data flow

To modify window behavior:
    1. Window properties: advanced_window_pool.ts createWindow()
    2. Initial position: shelf_manager.ts getDefaultPosition()
    3. Window size: shelf_manager.ts DEFAULT_SHELF_SIZE
    4. Content loading: shelf_manager.ts loadShelfContent()

To debug issues:
    1. Check main process logs: ~/Library/Application Support/FileCataloger/logs/
    2. Check renderer console: DevTools in development
    3. Check window pool stats: AdvancedWindowPool.getPoolStats()
    4. Monitor IPC messages: Rate limiter logs

=============================================================================
